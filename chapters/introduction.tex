\chapter{Introduction}
\epigraph{A programmer does not primarily write code; rather, he primarily writes to another programmer about his program solution.}{\textit{Unknown}}
Unfortunately the author of this rather social definition of a programmer's tasks was not handed down, nevertheless the article \textcite{noauthor_what_1967} collected by Don Knuth laid the foundation for human-centered programming.
Reading Peter Naur's influential article \citetitle{naur_programming_1985} written in \citeyear{naur_programming_1985} this human-centered approach to programming seems to be forgotten. Only 18 years later he states that: "[...] much current discussion of programming seems to assume that programming is similar to industrial production, the programmer being regarded as a component of that production, a component that has to be controlled by rules of procedure and which can be replaced easily."
At the same the interdisciplinary research field \emph{Psychology of Programming} originated \autocite{myers_past_2009}, indicating that this mismatch of what programming is and as what it is seen was recognized.


\section{Problem Definition}
\label{sec:problem-definition}
As stated in \textcite{noauthor_what_1967} programming is a communication process.
Even if programming is not seen as a mainly human-centered activity, translating thoughts into a language understood by machines is a form of communication, namely \emph{Human Computer Interaction} (HCI).
As software got more and more complex, the sole activity of programming transitioned to the much broader task of software development.
This process begins with the task of requirements analysis, after aquiring a common understanding in the whole team, those have to be implemented, tested and shipped to the customer \autocite{mayr_projekt_2005}.
Alone this extremely simplified description of software development exhibits the difference to programming.
Comparing this to the Psychology of Programming \citeauthor{curtis_psychology_1990} stated: "The fact that this field is usually referred to as the 'psychology of programming' rather than the 'psychology of software development' reflects its primary orientation to the coding phenomena." \autocite[267]{curtis_psychology_1990}.

In modern frameworks the process of software development happens iteratively and incrementally \autocite{mayr_projekt_2005} which means that user feedback is constantly incorporated into the development cycle.
New requirements arise or existing ones have to be adapted, in either case the software under development has to be adapted.
The basis for this adoption is communication, a human factor, that does not come without difficulties (see \cref{sec:characteristics-of-software-development-processes}).
As \citeauthor{curtis_psychology_1990} state in their essay \textcite{curtis_psychology_1990} mainly organizational processes characterize software development.

\emph{Source of truth} is a saying commonly used in software development for the place where something is defined.
Good software design favors a single source of truth, because then changing stuff means changing it only in one place.
Applying this idea to the whole software development process the single source of truth is the actual source code.
No matter what a requirements document defines or what the user documentation states, if those are not in sync with the source code, they "lose", the code \emph{speaks the real truth}.

So why not take \citeauthor{schraube_ich_2012}'s ideas \autocite{schraube_ich_2012} that technology influences people the same way they influence technology and apply those in a way that establishes a technology-based rethinking process inducing a change in organizational processes.


\section{Research Question}
The problem as previously described is usually not perceived as such one in the software development industry, it's just the characteristics of software development processes and inherently caused by the way software is currently produced.
In Bret Victor's words this \emph{problem} might rather be stated as a \emph{principle} of how software development might look like \autocite{victor_inventing_2012}.
The upcoming ideas emerged from the authors psychology internship at the company Innerspace GmbH in Wattens, Austria.
Usually employed as a software architect the author switched perspectives for two months and studied the software development process from an external view.
The company Innerspace creates virtual reality trainings for pharmaceutical companies.
One main difference to traditional web or desktop application development is the amount of interdisciplinary people involved in the process of creating virtual reality trainings.
In addition to software developers, 3D artists, training designers, narrators and game engineers are needed for content creation.
As stated in \cref{sec:problem-definition} in the end the source code is the actual source of truth.
Because 3D assets, narrations and the training flows are also artifacts of the development process they have to be aligned to this source of truth.

While researching possible technical solutions for the problem of managing state in complex applications like virtual reality trainings the author stumbled upon the rather old concept of \emph{Statecharts} \autocite{harel_statecharts:_1987}. Statecharts are a "visual formalism for complex systems". In more general words this means that Statecharts describe a mathematically proven visual language for creating computer programs. The visual notation is executable and can directly be aligned to a textual notation, which results in the fact, that a written program can be visualized automatically. This visualization combines flowcharts and state diagrams. On top of that this visualization provides simulation capabilities and therefore enables people to visually see and experiment with the logic of the program, without actually using the program. In fact, the program might not even exist at this point, but people can collaboratively design what the program should do. The main hypothesis is that this duality of visualization and executability enables the creation of a common mental model, resulting in a common basis of communication.

To further improve this communication process, the fractal nature of Statecharts (logic can be refined from abstract to concrete) is the perfect fit for hole driven development (see \cref{sec:hole-driven-development}). This relatively new idea of writing computer programs can be compared with a "fill in the blank"-exercise. Instead of having to write a complete program, developers can leave holes for the computer and then ask it to provide help based on mathematical reasoning. Applying this idea at the level of human interaction, the second hypothesis is that introducing holes in Statecharts (enabled by their fractal and composable nature) enables a new way of communicating, defining and refining requirements.

This leads to the research question: \emph{Which findings of cognitive and social psychology support the usage of Statecharts combined with hole driven development for enabling better communication in software development processes, or how can those concepts be adapted to closer align to the way the human brain works?}


% Utilizing the features of Statecharts and hole driven development to align this process closer to how people think might result in a huge productivity boost and take a lot of burden off the people involved in creating software.